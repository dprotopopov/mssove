#include "Header.hpp"
/********************************************************
Вычисление минора для квадратной матрицы

**data - матрица
size - сторона матрицы
strin - строка, где располагается минор
colon - столбец, где располагается минор
*********************************************************/
double minor(double **data, int size, int strin, int colon){
	double resultMinor;

	double **result = new double*[size-1];
	for(int i = 0; i < size-1; i++)
		result[i] = new double[size-1];

	//Создание новой матрицы из старой, выкидыванием столбца colon и строки strin
		// используется параллельная обработка элементов массива
		// Однородные вычислительные структуры или среды (ОВС), как правило, 
		// относятся к классу  ОКМД (согласно классификации Флинна) 
		// и представляют собой регулярную структуру из однотипных процессорных элементов (ПЭ).
		// Каждый ПЭ, в зависимости от типа ОВС, может как обладать алгоритмически полным набором 
		// операций, так и реализовывать один вид операций, жестко заданный в структуре микросхемы 
		// на этапе проектирования, а также выполнять операции обмена или взаимодействия с другими ПЭ.
		// OpenMP поддерживает директивы parallel, for, parallel for, section, sections, single, master, critical, flush, ordered и atomic, 
		// которые определяют или механизмы разделения работы или конструкции синхронизации. 
		// Общие переменные доступны всем потокам из группы, поэтому изменения таких переменных в одном потоке видимы другим потокам 
		// в параллельном регионе. Что касается частных переменных, то каждый поток из группы располагает их отдельными экземплярами, 
		// поэтому изменения таких переменных в одном потоке никак не сказываются на их экземплярах, 
		// принадлежащих другим потокам.
		// частными являются индексы параллельных циклов for.

#pragma omp parallel for
	for(int col = 0; col < size; col++){
#pragma omp parallel for
		for(int str = 0; str < size; str++){
			if(col != colon && str != strin)
				result[str-(str>strin)][col-(col>colon)] = data[str][col];
			}
		}
	resultMinor = det(size-1, result);//Вычисляем минор

	for(int i = 0; i < size-1; i++)
		delete []result[i];
	delete []result;

return resultMinor;
}