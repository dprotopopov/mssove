#include "Header.hpp"
using namespace std;

/********************************************************
Метод левых прямоугольников 

метод численного интегрирования функции одной переменной, 
заключающийся в замене подынтегральной функции на многочлен нулевой степени, 
то есть константу, на каждом элементарном отрезке. 
Если рассмотреть график подынтегральной функции, то метод будет заключаться в приближённом вычислении 
площади под графиком суммированием площадей конечного числа прямоугольников, 
ширина которых будет определяться расстоянием между соответствующими соседними узлами 
интегрирования, а высота — значением подынтегральной функции в этих узлах.

Для формул правых и левых прямоугольников погрешность составляет
E(f) = f'/2n * (b - a)^2.

Правило Рунге — правило оценки погрешности численных методов, 
было предложено К. Рунге в начале 20 века.[1]
Основная идея (для методов Рунге-Кутты решения ОДУ) состоит в вычислении приближения 
выбранным методом с шагом h, а затем с шагом h/2, и дальнейшем рассмотрении разностей 
погрешностей для этих двух вычислений.

Интеграл вычисляется по выбранной формуле (прямоугольников, трапеций, парабол Симпсона) 
при числе шагов, равном n, а затем при числе шагов, равном 2n. 
Погрешность вычисления значения интеграла при числе шагов, равном 2n, 
определяется по формуле Рунге:
Delta_{2n} = Theta * |I_{2n}-I_{n}|, для формул прямоугольников и трапеций Theta = 1/3

*pf - указатель на функцию 
a,b - диапазон интегрирования
е - точность
*********************************************************/
double integral(double (*pf)(double), double a, double b, double e, int demo){
	int nmin=10; // Минимальное число разбиения отрезка [a,b]
	double prev;
	double next;

	// Вычисление начального приближения
	prev=0; 
	for(int i=0; i<nmin; i++) 
		prev+=(*pf)(a+i*(b-a)/nmin); 
	prev /= nmin;

	// Итерации
	for(int n=nmin;;n++) {

		if(demo!=0) cout << "\tШаг итерации:" << n << endl;

		if(demo!=0) cout << "\tПредыдущее значение:" << prev << endl;

		double *y=new double[n];
#pragma omp parallel for
		for(int i=0; i<n; i++) 
			y[i]=(*pf)(a+(2*i+1)*(b-a)/(2*n)); 

		next=0; 
		for(int i=0; i<n; i++) 
			next+=y[i]; 

		delete y;

		next = (next / (2*n)) + (prev/2);

		if(demo!=0) cout << "\tСледующее значение:" << next << endl;

		// Правило Рунге — правило оценки погрешности численных методов
		double delta=abs(next-prev)/3;

		if(demo!=0) cout << "\tИзменение значения:" << delta << endl;

		if(demo!=0) {
			cout << "\tНажмите ВВОД для продолжения" << endl;
			getchar();
			getchar();
		}

		if(delta < e) break;

		prev=next;
	}
	return next;
}

