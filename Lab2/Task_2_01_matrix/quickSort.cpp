#include "Header.hpp"
/****************************************************
Быстрая сортировка Хоара

*data - массив элементов
left -  номер первого		элемента сортируемого массива
right - номер последнего	элемента сортируемого массива

https://msdn.microsoft.com/ru-ru/library/dd335940.aspx
В данном примере первая директива #pragma создает параллельный регион секций. 
Каждая секция определяется директивой #pragma omp section. 
Каждой секции в параллельном регионе ставится в соответствие один поток из группы потоков, 
и все секции выполняются одновременно. 
В каждой секции рекурсивно вызывается метод QuickSort.
Как и в случае конструкции #pragma omp parallel for, вы сами должны убедиться 
в независимости секций друг от друга, чтобы они могли выполняться параллельно. 
Если в секциях изменяются общие ресурсы без синхронизации доступа к ним, 
результат может оказаться непредсказуемым.
Обратите внимание на то, что в этом примере используется сокращение #pragma omp parallel sections, 
аналогичное конструкции #pragma omp parallel for. 
По аналогии с #pragma omp for директиву #pragma omp sections можно использовать 
в параллельном регионе отдельно.
По поводу кода, показанного в листинге , следует сказать еще пару слов. 
Прежде всего заметьте, что параллельные секции вызываются рекурсивно. 
Рекурсивные вызовы поддерживаются и параллельными регионами, и (как в нашем примере) 
параллельными секциями. Если создание вложенных секций разрешено, 
по мере рекурсивных вызовов QuickSort будут создаваться все новые и новые потоки. 
Возможно, это не то, что нужно программисту, так как такой подход может привести к созданию большого числа потоков. 
Чтобы ограничить число потоков, в программе можно запретить вложение. 
Тогда наше приложение будет рекурсивно вызывать метод QuickSort, 
используя только два потока.
При компиляции этого приложения без параметра /openmp будет сгенерирована 
корректная последовательная версия. Одно из преимуществ OpenMP в том, 
что эта технология совместима с компиляторами, не поддерживающими OpenMP.
*****************************************************/
void quickSort(double *data, int left, int right)
{
	int left1 = left;
	int right1 = right;
	double p;
	double ref = data[(left+right)/2];
		
	do{
		while(data[left1] < ref)left1++;
		while(data[right1] > ref)right1--;
		if(left1<=right1){
			if(data[left1] > data[right1])
				data[left1]  = (p = data[right1], data[right1] = data[left1], p);
			left1++;
			right1--;
		}
	}while (left1 <= right1);

      #pragma omp parallel sections
      {
         #pragma omp section
	if(left1 < right) 
		quickSort(data, left1, right);

         #pragma omp section
	if(left < right1) 
		quickSort(data, left, right1);
	  }
}