#include "Header.hpp"
using namespace std;

/********************************************************
Метод левых прямоугольников 

метод численного интегрирования функции одной переменной, 
заключающийся в замене подынтегральной функции на многочлен нулевой степени, 
то есть константу, на каждом элементарном отрезке. 
Если рассмотреть график подынтегральной функции, то метод будет заключаться в приближённом вычислении 
площади под графиком суммированием площадей конечного числа прямоугольников, 
ширина которых будет определяться расстоянием между соответствующими соседними узлами 
интегрирования, а высота — значением подынтегральной функции в этих узлах.

Для формул правых и левых прямоугольников погрешность составляет
E(f) = f'/2n * (b - a)^2.

Правило Рунге — правило оценки погрешности численных методов, 
было предложено К. Рунге в начале 20 века.[1]
Основная идея (для методов Рунге-Кутты решения ОДУ) состоит в вычислении приближения 
выбранным методом с шагом h, а затем с шагом h/2, и дальнейшем рассмотрении разностей 
погрешностей для этих двух вычислений.

Интеграл вычисляется по выбранной формуле (прямоугольников, трапеций, парабол Симпсона) 
при числе шагов, равном n, а затем при числе шагов, равном 2n. 
Погрешность вычисления значения интеграла при числе шагов, равном 2n, 
определяется по формуле Рунге:
Delta_{2n} = Theta * |I_{2n}-I_{n}|, для формул прямоугольников и трапеций Theta = 1/3

*pf - указатель на функцию 
a,b - диапазон интегрирования
е - точность
*********************************************************/
double integral(double (*pf)(double), double a, double b, double e, int demo){
	int nmin=10; // Минимальное число разбиения отрезка [a,b]
	double prev;
	double next;

	// Вычисление начального приближения
	prev=0; 
	for(int i=0; i<nmin; i++) 
		prev+=(*pf)(a+i*(b-a)/nmin); 
	prev /= nmin;

	// Итерации
	for(int n=nmin;;n++) {

		if(demo!=0) cout << "\tШаг итерации:" << n << endl;

		if(demo!=0) cout << "\tПредыдущее значение:" << prev << endl;

		double *y=new double[n];

		// используется параллельная обработка элементов массива
		// Однородные вычислительные структуры или среды (ОВС), как правило, 
		// относятся к классу  ОКМД (согласно классификации Флинна) 
		// и представляют собой регулярную структуру из однотипных процессорных элементов (ПЭ).
		// Каждый ПЭ, в зависимости от типа ОВС, может как обладать алгоритмически полным набором 
		// операций, так и реализовывать один вид операций, жестко заданный в структуре микросхемы 
		// на этапе проектирования, а также выполнять операции обмена или взаимодействия с другими ПЭ.
		// OpenMP поддерживает директивы parallel, for, parallel for, section, sections, single, master, critical, flush, ordered и atomic, 
		// которые определяют или механизмы разделения работы или конструкции синхронизации. 
		// Общие переменные доступны всем потокам из группы, поэтому изменения таких переменных в одном потоке видимы другим потокам 
		// в параллельном регионе. Что касается частных переменных, то каждый поток из группы располагает их отдельными экземплярами, 
		// поэтому изменения таких переменных в одном потоке никак не сказываются на их экземплярах, 
		// принадлежащих другим потокам.
		// частными являются индексы параллельных циклов for.

#pragma omp parallel for
		for(int i=0; i<n; i++) 
			y[i]=(*pf)(a+(2*i+1)*(b-a)/(2*n)); 

		// Суммирование элементов требует дополнительных обработок для параллельных вычислений
		// Поэтому используется непараллельная версия
		next=0; 
		for(int i=0; i<n; i++) 
			next+=y[i]; 

		delete y;

		next = (next / (2*n)) + (prev/2);

		if(demo!=0) cout << "\tСледующее значение:" << next << endl;

		// Правило Рунге — правило оценки погрешности численных методов
		double delta=abs(next-prev)/3;

		if(demo!=0) cout << "\tИзменение значения:" << delta << endl;

		if(demo!=0) {
			cout << "\tНажмите ВВОД для продолжения" << endl;
			getchar();
			getchar();
		}

		if(delta < e) break;

		prev=next;
	}
	return next;
}

