#include "Header.hpp"
/*****************************************************************
Вычисление обратной матрицы (только для квадратных)

**data - матрица
size - сторона матрицы

Функция возвращает NULL, если обратной матрицы не существует.
*****************************************************************/
double **inverse(double **data, int size){
	double **additionMatrix;//Матрица алгебраических дополнений
	double detData;


	if((detData = det(size, data)) == 0)//вычисляем детерминант, если он равен нулю, то обратной матрицы не существует
		return NULL;


	additionMatrix = new double*[size];
	for(int str = 0; str < size; str++)
		additionMatrix[str] = new double[size];
	
	//Отдельный случай для матрицы 1х1
	if(size == 1)
	{
		additionMatrix[0][0] = 1/data[0][0];
		return additionMatrix;
	}

	//Составляем матрицу алгебраических дополнений
	// используется параллельная обработка элементов массива
		// Однородные вычислительные структуры или среды (ОВС), как правило, 
		// относятся к классу  ОКМД (согласно классификации Флинна) 
		// и представляют собой регулярную структуру из однотипных процессорных элементов (ПЭ).
		// Каждый ПЭ, в зависимости от типа ОВС, может как обладать алгоритмически полным набором 
		// операций, так и реализовывать один вид операций, жестко заданный в структуре микросхемы 
		// на этапе проектирования, а также выполнять операции обмена или взаимодействия с другими ПЭ.
		// OpenMP поддерживает директивы parallel, for, parallel for, section, sections, single, master, critical, flush, ordered и atomic, 
		// которые определяют или механизмы разделения работы или конструкции синхронизации. 
		// Общие переменные доступны всем потокам из группы, поэтому изменения таких переменных в одном потоке видимы другим потокам 
		// в параллельном регионе. Что касается частных переменных, то каждый поток из группы располагает их отдельными экземплярами, 
		// поэтому изменения таких переменных в одном потоке никак не сказываются на их экземплярах, 
		// принадлежащих другим потокам.
		// частными являются индексы параллельных циклов for.

#pragma omp parallel for
	for(int str = 0; str < size; str++)
#pragma omp parallel for
		for(int col = 0; col < size; col++)
			if(((str+col) % 2) == 0)
				additionMatrix[str][col] =  minor(data, size, str, col);
			else
				additionMatrix[str][col] = -minor(data, size, str, col);

	transposeSQR(additionMatrix, size);//транспонируем матрицу

	// используется параллельная обработка элементов массива
		// Однородные вычислительные структуры или среды (ОВС), как правило, 
		// относятся к классу  ОКМД (согласно классификации Флинна) 
		// и представляют собой регулярную структуру из однотипных процессорных элементов (ПЭ).
		// Каждый ПЭ, в зависимости от типа ОВС, может как обладать алгоритмически полным набором 
		// операций, так и реализовывать один вид операций, жестко заданный в структуре микросхемы 
		// на этапе проектирования, а также выполнять операции обмена или взаимодействия с другими ПЭ.
		// OpenMP поддерживает директивы parallel, for, parallel for, section, sections, single, master, critical, flush, ordered и atomic, 
		// которые определяют или механизмы разделения работы или конструкции синхронизации. 
		// Общие переменные доступны всем потокам из группы, поэтому изменения таких переменных в одном потоке видимы другим потокам 
		// в параллельном регионе. Что касается частных переменных, то каждый поток из группы располагает их отдельными экземплярами, 
		// поэтому изменения таких переменных в одном потоке никак не сказываются на их экземплярах, 
		// принадлежащих другим потокам.
		// частными являются индексы параллельных циклов for.

#pragma omp parallel for
	for(int str = 0; str < size; str++)//делим элементы на детерминант
#pragma omp parallel for
		for(int col = 0; col < size; col++)
			additionMatrix[str][col] /= detData;


	return additionMatrix;
}
