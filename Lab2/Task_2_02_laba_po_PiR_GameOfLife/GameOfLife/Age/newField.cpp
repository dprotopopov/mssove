#include "Header.hpp"
/***************************************************************
Обновление поля
field[WIDTH][HEIGHT] - текущее поле.

Возвращает true, если поле изменило своё состояние, иначе false
***************************************************************/
bool newField(cell field[WIDTH][HEIGHT])
{
	int countNeighbors = 0;			//Количество живых соседей
	bool notStatState = false;		//Возвращаемое значение
	cell newField[WIDTH][HEIGHT];
	

		// используется параллельная обработка элементов массива
		// Однородные вычислительные структуры или среды (ОВС), как правило, 
		// относятся к классу  ОКМД (согласно классификации Флинна) 
		// и представляют собой регулярную структуру из однотипных процессорных элементов (ПЭ).
		// Каждый ПЭ, в зависимости от типа ОВС, может как обладать алгоритмически полным набором 
		// операций, так и реализовывать один вид операций, жестко заданный в структуре микросхемы 
		// на этапе проектирования, а также выполнять операции обмена или взаимодействия с другими ПЭ.
		// OpenMP поддерживает директивы parallel, for, parallel for, section, sections, single, master, critical, flush, ordered и atomic, 
		// которые определяют или механизмы разделения работы или конструкции синхронизации. 
		// Общие переменные доступны всем потокам из группы, поэтому изменения таких переменных в одном потоке видимы другим потокам 
		// в параллельном регионе. Что касается частных переменных, то каждый поток из группы располагает их отдельными экземплярами, 
		// поэтому изменения таких переменных в одном потоке никак не сказываются на их экземплярах, 
		// принадлежащих другим потокам.
		// частными являются индексы параллельных циклов for.

#pragma omp parallel for
	for(int h = 0; h < HEIGHT; h++)
#pragma omp parallel for
		for(int w = 0; w < WIDTH; w++)
		{
			countNeighbors = 0;
			countNeighbors += field[w == 0 ? WIDTH-1 : (w-1)]	[h]							 .currentState;
			countNeighbors += field[(w+1)%WIDTH]				[h]							 .currentState;
			countNeighbors += field[w]							[h == 0 ? HEIGHT - 1 : (h-1)].currentState;
			countNeighbors += field[w]							[(h+1)%HEIGHT]				 .currentState;
			newField[w][h].currentState = newState(field[w][h].currentState, countNeighbors);
			if(newField[w][h].currentState != field[w][h].currentState)
				notStatState = true;

			//Проверка на достижение максимального возраста
			if(field[w][h].age >= MAX_AGE)
				newField[w][h].currentState = false;


			//Обнуление возраста при смерти
			if((newField[w][h].currentState == true) && (field[w][h].currentState == false))
				field[w][h].age = 0;

			//Увеличение возраста живой клетки
			if((newField[w][h].currentState == true) && (field[w][h].currentState == true))
				++field[w][h].age;

			//Проверка на достижение максимального возраста
			if(field[w][h].age >= MAX_AGE)
				newField[w][h].currentState = false;

		}


		// используется параллельная обработка элементов массива
		// Однородные вычислительные структуры или среды (ОВС), как правило, 
		// относятся к классу  ОКМД (согласно классификации Флинна) 
		// и представляют собой регулярную структуру из однотипных процессорных элементов (ПЭ).
		// Каждый ПЭ, в зависимости от типа ОВС, может как обладать алгоритмически полным набором 
		// операций, так и реализовывать один вид операций, жестко заданный в структуре микросхемы 
		// на этапе проектирования, а также выполнять операции обмена или взаимодействия с другими ПЭ.
		// OpenMP поддерживает директивы parallel, for, parallel for, section, sections, single, master, critical, flush, ordered и atomic, 
		// которые определяют или механизмы разделения работы или конструкции синхронизации. 
		// Общие переменные доступны всем потокам из группы, поэтому изменения таких переменных в одном потоке видимы другим потокам 
		// в параллельном регионе. Что касается частных переменных, то каждый поток из группы располагает их отдельными экземплярами, 
		// поэтому изменения таких переменных в одном потоке никак не сказываются на их экземплярах, 
		// принадлежащих другим потокам.
		// частными являются индексы параллельных циклов for.

#pragma omp parallel for
	for(int h = 0; h < HEIGHT; h++)
#pragma omp parallel for
		for(int w = 0; w < WIDTH; w++)
				field[w][h].currentState = newField[w][h].currentState;
		return notStatState;
}