#include "Header.hpp"
/*******************************************
ќпределитель квадратной матрицы

size - сторона матрицы
**data - матрица

*******************************************/
double det(int size, double **data){
	int str, col, currCol;
	double result = 0;//результат выполнени€ (детерминант)

		double *temp = new double[size+1]; //+1 дл€ нулевого размера


	if(size == 1)
		return data[0][0];

		// используетс€ параллельна€ обработка элементов массива
		// ќднородные вычислительные структуры или среды (ќ¬—), как правило, 
		// относ€тс€ к классу  ќ ћƒ (согласно классификации ‘линна) 
		// и представл€ют собой регул€рную структуру из однотипных процессорных элементов (ѕЁ).
		//  аждый ѕЁ, в зависимости от типа ќ¬—, может как обладать алгоритмически полным набором 
		// операций, так и реализовывать один вид операций, жестко заданный в структуре микросхемы 
		// на этапе проектировани€, а также выполн€ть операции обмена или взаимодействи€ с другими ѕЁ.
		// OpenMP поддерживает директивы parallel, for, parallel for, section, sections, single, master, critical, flush, ordered и atomic, 
		// которые определ€ют или механизмы разделени€ работы или конструкции синхронизации. 
		// ќбщие переменные доступны всем потокам из группы, поэтому изменени€ таких переменных в одном потоке видимы другим потокам 
		// в параллельном регионе. „то касаетс€ частных переменных, то каждый поток из группы располагает их отдельными экземпл€рами, 
		// поэтому изменени€ таких переменных в одном потоке никак не сказываютс€ на их экземпл€рах, 
		// принадлежащих другим потокам.
		// частными €вл€ютс€ индексы параллельных циклов for.

#pragma omp parallel for
	for(col = 0; col < size; col++){
		double **newData = new double*[size-1];

		for(str = 0; str < size-1; str++)
			newData[str] = new double[size-1];

		//—оздание новой матрицы из старой, выкидыванием столбца col и строки str
		for(currCol = 0; currCol < size; currCol++){
			if(currCol != col)
				for(str = 1; str < size; str++){
						newData[str-1][currCol-(currCol>col)] = data[str][currCol];
					}
				}
		if(col%2)
			temp[col] =- data[0][col]*det(size-1, newData);
		else
			temp[col] = data[0][col]*det(size-1, newData);

		for(int i = 0; i < size-1; i++)
			delete []newData[i];

		delete []newData;
	}

	for(col = 0; col < size; col++) result+=temp[col];
	delete temp;

	return result;
}
